# 数算学习心得

## 学习方法

相较于计概，数算侧重对问题的建模，而且理论（笔试）与实际（代码）并重。因此，学习时要不仅要理解数据结构的设计初衷，它要解决什么样的问题，它采用什么样的（面向对象的方法）实现。

本人笔试答得实在不好，就不对笔试发表学习意见了。

### 面向对象

尽管我们在做编程题目时的目的是AC，但是在学习时应该对自己的代码有更高的要求。如果对软件工程有了解，应该知道好的代码应该是**可复用、可拓展、可维护**的，并且软件设计有五大原则（SOLID原则），这对我们在实现数据结构时具有指导意义。一个结构有物理存储结构（成员变量），也有逻辑结构，逻辑结构支持的各种操作，就是接口，通过类的方法（成员函数）实现（其中也包括重载，即Python中的魔法方法）。

比如，栈、队列同为线性表，它们都可以有接口pop_front，push_back等，我们在学习不同的数据结构时要注意他们之间的联系（共有的接口）和区别（实现同一功能的不同方式和效率），这样的思想也是面向对象的。

### 机考

DFS和BFS我当做计概内容了，计概时做题比较多的是在一个矩阵里搜索（比如counting lake这种题目），如果涉及到更一般的图，其实也不难，写过一两遍就会了。

线性表、排序，这部分内容机考题不多，大多数是模拟，注意选取合适的数据结构，利用基本操作即可。难点主要是**单调栈、单调队列、辅助栈**，以及排序的应用**求逆序对**。还有是三种表达式（前序、中序、后序）的互相转换，最难的是涉及中序的，需要额外记忆**调度场算法**。

树这部分，主要练习递归。两大部分，**建树**和**遍历树**。遍历树稍简单些，前序中序后序是很经典的递归应用，BFS则使用队列。建树稍难些，但如果刷过几道OJ题（OJ22158:根据二叉树前中序序列建树http://cs101.openjudge.cn/2024sp_routine/22158/，OJ24750:根据二叉树中后序序列建树http://cs101.openjudge.cn/dsapre/24750/）就能体会到，这不过是找节点之间的先后顺序，把序列分成两半然后递归就好，相对来说还算直观。

接下来是**并查集**。原理简单，理解路径压缩即可，按秩合并略有了解即可（事实上，我们做过的题大多都无需合并，而且合并会带来指向的不是最深的节点的问题）。OJ01703:发现它，抓住它http://cs101.openjudge.cn/2024sp_routine/01703/和OJ01182:食物链http://cs101.openjudge.cn/2024sp_routine/01182/是两道很经典的拓展，思路相似，都是划分为几个类，然后使用几倍长的数组储存集合。

**堆**很有用，要熟悉它的接口。由于Python有内置的，导致很多人忘记了它的实现：上浮下沉。本学期机考题，堆路径，这题很多人觉得是建树，但其实直接用堆的性质，父子节点之间索引的对应关系就非常简单（其实我们有一次作业要求手动时间堆，涉及到了这个知识点）。

**Huffman树、字典树**，题不多，但是要掌握原理，做一两个题即可。

**图**部分算法较多。在**图的实现**方面，要知道如何建立、使用图的邻接矩阵。其实，我们在做题中更常见的应该是用字典（或者桶）来快速存取邻居节点。在一般的图上进行DFS、BFS，需要熟练掌握。

**拓扑排序**理解不难，但是很难灵活运用。例题OJ01094:Sorting It All Outhttp://cs101.openjudge.cn/dsapre/01094/，告诉我们拓扑排序的应用（判断有无环）以及拓扑排序是否唯一。

**Dijkstra算法**是很经典的单元最短路，使用堆实现，注意要掌握如何记录最短路的路径。

**最小生成树（Prim算法、Kruskal算法）**更难一些，基本掌握算法本身即可。

对于图部分的学习需要再提一句，方才提到的四种算法大多要借助其他结构实现，比如优先队列等。要深刻理解为什么要使用这些结构。如果只是一知半解地掌握模板，只能应对模板题。比如，OJ01094:Sorting It All Out里，我们学习到若拓扑排序后有顶点入度不为0，则有环；若同一时间队列长度大于1，则给出的条件不足以唯一确定拓扑排序。在OJ07735:道路http://cs101.openjudge.cn/practice/07735/中学到，dijkstra算法中，加入优先队列的条件不是距离更短，而是金币够用，但是优先队列的比较仍然是用距离比的。

另，在我的机考notes里，给出了各个知识点的最经典例题，基本是模板题+小拓展。掌握这些题，基本覆盖了机考内容。

## 学习经历&感悟

寒假基本没碰编程，开学到期中以前为了复习Python（也预料到了五一之后可能更忙），所以集中精力做了很多题，在树的部分基本上做到了非常熟练的地步。五一之后比较忙，图这部分做题不多，不能靠量积累熟练度，所以要高质量做题。五一之前，每日选做都跟上了，五一之后，主要做图的题，树的题做的稍微少些。刚开学的一两周，由于复习计概题目，我就在数算pre里面把几乎所有树的题目挑出来全做了。所以我树的题目掌握得比较好。最后，每日选做除了一些英文题目和计概题目，基本差不多，150+题里做了一百多题，其他没做的，也都看题解，了解了思路。

今年的机考题，整体来讲难度小于作业和每日选做的题目，尤其是没有出图的算法题。前面几道题做得很快，最后一题识别出来是并查集，但是由于受到了食物链这题的思维定势，WA了7次才做出来，最终达成开学时AC6的目标。但是笔试可谓惨败，复习时主要依靠讲义和同学们的cheat sheet，但是讲义太长了没有完整看完，大家在群里分享的笔记，我基本上都看了一遍，最后选了两个同学的，全面且简洁，再加上我自己补充的一些内容一起打印出来。但是笔试最后只有80分：代码填空部分，prim的写法没有用优先队列，导致我想了很长时间，而建树那道题思维陷入死胡同，判断根节点的方法，如果我在上机时肯定很熟练了，但是笔试的时候愣是没想出来。此外，填空选择仍然有一些没有复习到位的知识点，也有理解错题意的地方，导致最后只有80分。这个成绩还是有点遗憾，群里大家都很优秀，只希望最后笔试占比至多能像开学时说的40%（80分对应总评扣8分），这样最多总评-8。因为一开始听说重上机，所以笔试没有投入很多精力。不过也怪我自己对理论知识的理解不够充分，很多细碎的知识点没有复习到位。

闫老师的群里讨论氛围十分浓厚，我从大家的讨论中收获颇丰。比如课程要求使用md和github，我之前一直觉得这些东西有用，但是一直没学，多亏这门课，我掌握了markdown这一高效记笔记的方式，以及管理github。以及，在讨论中，还学到了Python的很多技巧，lru_cache，各种方便的内置模块，default dict，permutation，set recursion limit这些小的东西。当然，更多的是很多问题奇妙的解法和思想，对题解的讨论，大家善于发现新知识、新方法，遇到好题也愿意分享。能看到，很多人是热爱编程的，并不是把这门课单纯的当做课在学，而是出于内心的追求。这种互帮互助而不是内卷的氛围，加上老师近乎24小时的答疑，就足够让我给这门打满分的好评了。

希望这门课越来越好，希望大家在探索计算机科学中收获知识、友谊和快乐！
