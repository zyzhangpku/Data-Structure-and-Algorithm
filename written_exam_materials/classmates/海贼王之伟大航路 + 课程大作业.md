#### [1. OpenJudge: 海贼王之伟大航路](http://cxsjsx.openjudge.cn/hw202316/C/)

- 法一：状压 dp 

  - 本题就是算法基础课状压 dp 例题[AcWing: 最短Hamilton路径](https://www.acwing.com/problem/content/93/)；正如题目名，这种每个点经过且只经过一次的路径就叫 Hamilton 路径，其最短路一般用状压 dp 求；可参考[题解](https://www.acwing.com/solution/content/15328/)；另外，这类问题也称为 TSP(Traveling Salesman Problem) 问题，其重点在于**每个点经过且只经过一次**；在每个点经过且只经过一次的条件下，若我们没有要求必须从哪个点出发到哪个点结束，那每一个可能的方案就与 $0,1,...,n-1$ 这 $n$ 个点的一种的排列顺序一一对应，于是一共有 $n!$ 中方案；若只要从 $0$ 出发到达 $n-1$ 的方案，那便是中间 $1, 2, ..., n - 2$ 这 $n - 2$ 个点的全排列

  - 状态表示：`dp[i][j]`表示当前走过的点（含终点）为二进制数`i`的条件下，到达`j`点的所有路径中总距离的最小值

  - 状态计算：

    - 按照“最后一步操作方式”划分集合，也就是划分为当前走过的点（含终点）为二进制数`i`的条件下，到达`k`点后再到达`j`点，其中`k`点在`i`表示的走过的点中（否则不能从它转移）

    - `dp[i][j] = dp[i ^ 1 << j][k] + w[k][j]`

    - 最小子问题：从状态转移方程中递归地考虑，可以发现 base case 就是`dp[1][0] = 0`，即只走过起点且终点为起点的最短路是 0

    - 迭代顺序: 

      - 正如之前在板子里总结的，看状态转移方程中需要什么
      - In order for this computation to be correct, we need to have already computed `dp[i ^ 1 << j][k]` for all `k` and `j` in state `i` before we compute `dp[i][j]`. This is ensured by the ordering of the loops, because we iterate over states in increasing order of their bitmasks. For any `i` and `j`, the bitmask of `i ^ 1 << j` is always smaller than the bitmask of `i`. Therefore, if we keep the order of the loops as is, we will always have computed `dp[i ^ 1 << j][k]` before we compute `dp[i][j]`. But if we were to swap the order of the `i` and `j` loops, we would be iterating over vertices before states, which does not guarantee that `dp[i ^ 1 << j][k]` is computed before `dp[i][j]`. So the order of the loops cannot be swapped.
      - 由于第三层循环要 iterate over `k`，所以前两层循环要保证在转移时**对于任意的`k`**，`dp[i ^ 1 << j][k]`是已经更新好的值，也就是要先更新`dp[i][j]`在第一维`i`选定后，第二维`j`所有取值下的值（因为`k`在第二维）；又因为`i ^ 1 << j`是小于`i`的，所以 iterate over `i`的时候从小到大进行，而`j`的顺序的无所谓

    - ```cpp
      for (int i = 1; i < (1 << n); i ++ )
          for (int j = 0; j < n; j ++ )
              if (i >> j & 1)
                  for (int k = 0; k < n; k ++ )
                      if ((i ^ 1 << j) >> k & 1) 
                          // 这里如果写 if(i >> k & 1) 的话不妥，因为会多从一种不合法状态中更新
                          // 即k = j时会用到dp[i ^ 1 << j][j]这个不合法状态
                          // 但因为之前把dp数组memset成了0x3f3f3f3f，更新时不会被使用，所以也能ac
                          dp[i][j] = min(dp[i][j], dp[i ^ 1 << j][k] + w[k][j]);
      ```

- 法二：dfs + 剪枝（事实上核心思想和方法一相同，只不过更暴力一点，仅仅把状压 dp 的思想用于剪枝，本质是聪明的穷举，没有把问题拆解为子问题来解决）

  - ```cpp
    #include <cstring>
    #include <iostream>
    
    using namespace std;
    
    const int N = 16;
    
    int g[N][N];
    bool vis[N];
    int n, ans = 0x3f3f3f3f, stMinDist[1 << N][N];
    // 和dp解法类似，这里的stMinDist[i][j]表示状态为i终点为j的最短路
    
    void dfs(int u, int dep, int sum, int st) // 参数意义统一一下：此处都表示“当前”状况，进到dfs就代表当前到点u，一共到了dep个点，总路径和为sum，二进制状态为st
    {
        if (sum >= ans) return; // 普通的最优性剪枝
        if (dep == n - 1) // (1)这里保证了“走遍n个点”；因为0和n - 1号点是必走的，走了n - 1个点后下一个再走到第n - 1号点（见下方）然后终止
        {
            ans = min(ans, sum + g[u][n - 1]);
            return;
        }
    
        for (int i = 1; i <= n - 2; i ++ )
            if (!vis[i]) // (2)这里保证了“走过的点里没有重复的”，因为走过的就不再走
            {   
                int nst = 1 << i | st;
                if (sum + g[u][i] >= stMinDist[nst][i]) continue; // 状压剪枝
                stMinDist[nst][i] =  sum + g[u][i];
                vis[i] = true;
                dfs(i, dep + 1, sum + g[u][i], nst);
                vis[i] = false;
            }
        // 结合(1)(2)，我们保证了从0出发走到n - 1，一共走了n个点，且走过的点里没有重复的，所以就是一条Hamilton路径
    }
    
    int main() {
        cin >> n;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                cin >> g[i][j];
    
        memset(stMinDist, 0x3f, sizeof stMinDist);
        stMinDist[1][0] = 0;
        vis[0] = 1;
        dfs(0, 1, 0, 1);
    
        cout << ans << endl;
    }
    ```



#### [2. OpenJudge: 课程大作业](http://cxsjsx.openjudge.cn/hw202315/D/)

- 和上面很像，也是状压 dp：

  - 状态表示：
    - `dp[i]`表示 完成的作业是二进制状态`i`时的所有方案集合 的最小扣分；
    - **为什么比上一题少一维？**
      - 原因在于本题更新`dp`数组时不需要知道`i ^ 1 << j`这个状态最后完成的是哪一件事，即`penalty(i ^ 1 << j, j))`这一项由`i ^ 1 << j`这个状态结合下一件事是`j`即可算出；具体来说，本题的前`u - 1`件事情的顺序（即`i ^ 1 << j`这个状态已经做了的事情）只影响前`u - 1`件事情的扣分，而不影响第`u`件事情即事件`j`的扣分，因为前`u - 1`件事情无论按什么顺序做，它们的总时长是一定的，这使得事件`j`的开始时间确定（即`nowTime(i ^ 1 << j)`确定），而`penalty(i ^ 1 << j, j) = ReLU(nowTime[i ^ 1 << j] + w[j] - ddl[j])`自然也就不需要知道`i ^ 1 << j`这个状态最后完成的是哪一件事情；但上一题中需要进一步把`i ^ 1 << j`这些状态按最后一件事划分，因为`i ^ 1 << j`这个状态最后到达的是哪个点会影响到达下一个点（即`j`点）的距离，即转移方程中的`w[k][j]`项与`k`有关
      - 事实上，状态表示要满足无后效性才能成功地状态转移，而如果不满足无后效性，就说明状态表示中蕴含的信息不足，可以增加 dp 数组的维度来记录更多的信息，从而实现无后效性

  - 状态计算：
    - 按照最后一步操作方式来划分集合，即划分为 完成的作业是二进制状态`i`且最后完成第`j`个作业的所有做法集合，其中`j`从`0`开始取
    - `dp[i] = min(dp[i ^ 1 << j] + penalty(i ^ 1 << j, j))`, for all `j` such that `1 << j & i == true`
    - `penalty(i ^ 1 << j, j)`表示在已完成的作业为二进制状态`i ^ 1 << j`时，再来完成`j`作业会被扣的分数，其值就等于`ReLU(nowTime[i ^ 1 << j] + w[j] - ddl[j])`或`ReLU(nowTime[i] - ddl[j])`，其中`nowTime[i]`表示已完成的作业为二进制状态`j`时到达的时刻（初始时刻为 0），`ddl[j]`表示事件`j`的 deadline
    - 最小子问题：和上一题的区别在于，上一题限定了必须从 0 号点出发，其 base case 就是二进制状态`i = 1`对应的情况（只经过 0 号点）；而本题没有这一限定，容易发现本题的 base case 是二进制状态`i = 0`对应的情况，即什么作业都没做

- 以上都很好处理，麻烦的点在于有多个最优方案时，我们要输出的是“字典序小的”，脑子里要有清晰的概念，既然谈到字典序那肯定是对字符串而言的，要把问题 formulate 好，不能模模糊糊地就过去了；**事实上这里要输出的是：在所有课程名称后面拼接上`\n`得到的字符串中最小的那一个**；我们用`ans[i]`来表示`i`状态对应的字符串即可，注意更新的细节，见代码：

- ```cpp
  #include <cstring>
  #include <iostream>
  
  using namespace std;
  
  const int N = 15;
  
  int ddl[N], w[N], dp[1 << N], nowTime[1 << N];
  string name[N], ans[1 << N];
  
  inline int relu(int x) {
      return max(x, 0);
  }
  
  int main() {
      int t; cin >> t;
      while (t -- ) {
          int n; cin >> n;
          for (int i = 0; i < n; i ++ ) cin >> name[i] >> ddl[i] >> w[i];
          
          // 初始化base case
          memset(dp, 0x3f, sizeof dp);
          dp[0] = 0;
          nowTime[0] = 0;
          ans[0] = "";
  		
          for (int i = 1; i < (1 << n); i ++ )
              for (int j = 0; j < n; j ++ ) {
                  if (1 << j & i) {
                      nowTime[i] = nowTime[i ^ 1 << j] + w[j];
                      int st = i ^ 1 << j;
                      int new_dp = dp[st] + relu(nowTime[st] + w[j] - ddl[j]);
                      string new_ans = ans[st] + name[j] + '\n';
                      if (new_dp < dp[i]) // 有更小的dp就一定更新ans
                      {
                          ans[i] = new_ans;
                          dp[i] = new_dp;
                      }
                      else if (new_dp == dp[i]) // dp值相同时ans就更新为（字典序）小的
                          ans[i] = min(ans[i], new_ans);  
                  }
              }
      
          cout << dp[(1 << n) - 1] << '\n' << ans[(1 << n) - 1];    
      }
  }
  ```

